# generator.py
import os
import argparse
from jinja2 import Environment, FileSystemLoader
from parser import parse_manifest, LlmAgentResource, SequentialAgentResource, ToolResource, LlmModelResource
from typing import List

# --- JINJA2 TEMPLATES ---

TOOLS_PY_TEMPLATE = """
# This file is auto-generated by the ADK code generator.
# Do not edit this file directly.

# Import tool functions from their source files
{% for tool in tools %}
from {{ tool.spec.source.file.replace('.py', '').replace('/', '.') }} import {{ tool.spec.source.functionName }}
{% endfor %}
"""


MAIN_PY_TEMPLATE = """
# This file is auto-generated by the ADK code generator.
# Do not edit this file directly.

import asyncio
from google.adk.runners import Runner
from google.adk.sessions import InMemorySessionService
from google.genai.types import Content, Part
from .agent import root_agent

async def main():
    \"\"\"Main function to run the agent interactively.\"\"\"
    app_name = "generated-poc-app"
    user_id = "user-123"
    session_service = InMemorySessionService()

    runner = Runner(
        agent=root_agent,
        app_name=app_name,
        session_service=session_service,
    )

    session = await session_service.create_session(app_name=app_name, user_id=user_id)
    print(f"Agent '{root_agent.name}' is ready. Type 'exit' to quit.")

    while True:
        query = input("You: ")
        if query.lower() == "exit":
            break

        user_message = Content(parts=[Part(text=query)])
        
        final_response = ""
        async for event in runner.run_async(
            session_id=session.id, user_id=user_id, new_message=user_message
        ):
            if event.is_final_response() and event.content and event.content.parts:
                final_response = event.content.parts[0].text
        
        print(f"Agent: {final_response}")

if __name__ == "__main__":
    asyncio.run(main())
"""

def find_root_agent(
    llm_agents: List[LlmAgentResource],
    sequential_agents: List[SequentialAgentResource]
) -> str:
    # ... (Same as before)
    all_sub_agent_refs = set()
    for seq_agent in sequential_agents:
        all_sub_agent_refs.update(seq_agent.spec.subAgentRefs)

    all_agents = llm_agents + sequential_agents
    possible_roots = [
        agent for agent in all_agents if agent.metadata.name not in all_sub_agent_refs
    ]

    if not possible_roots:
        raise ValueError("Could not determine a root agent. Check for circular dependencies.")
    
    root_agent_name = possible_roots[0].metadata.name
    print(f"Identified '{root_agent_name}' as the root agent.")
    return root_agent_name

def generate_code(
    llm_agents: List[LlmAgentResource],
    sequential_agents: List[SequentialAgentResource],
    tools: List[ToolResource],
    llm_models: List[LlmModelResource],
    output_dir: str
):
    """Generates ADK Python code from parsed resources."""
    os.makedirs(output_dir, exist_ok=True)
    
    # Using FileSystemLoader is better practice for multi-template projects
    script_dir = os.path.dirname(os.path.abspath(__file__))
    env = Environment(loader=FileSystemLoader(script_dir))
    
    root_agent_name = find_root_agent(llm_agents, sequential_agents)

    # Generate tools.py
    tools_template = env.from_string(TOOLS_PY_TEMPLATE)
    tools_code = tools_template.render(tools=tools)
    with open(os.path.join(output_dir, "tools.py"), "w") as f:
        f.write(tools_code)
    print(f"Generated {output_dir}/tools.py")

    # Generate agent.py
    agent_template = env.get_template('agent_py.j2') 
    agent_code = agent_template.render(
        llm_agents=llm_agents,
        sequential_agents=sequential_agents,
        tools=tools,
        llm_models=llm_models, # <-- Pass models to the template
        root_agent_name=root_agent_name
    )
    with open(os.path.join(output_dir, "agent.py"), "w") as f:
        f.write(agent_code)
    print(f"Generated {output_dir}/agent.py")

    # Generate main.py
    main_template = env.from_string(MAIN_PY_TEMPLATE)
    main_code = main_template.render()
    with open(os.path.join(output_dir, "main.py"), "w") as f:
        f.write(main_code)
    print(f"Generated {output_dir}/main.py")
    
    # Create __init__.py
    with open(os.path.join(output_dir, "__init__.py"), "w") as f:
        f.write("# Auto-generated __init__.py")
    print(f"Generated {output_dir}/__init__.py")

if __name__ == '__main__':
    cli_parser = argparse.ArgumentParser(description="Generate ADK agent code from a YAML manifest.")
    cli_parser.add_argument("manifest_file", type=str, help="Path to the input YAML manifest file.")
    cli_parser.add_argument(
        "-o", "--output-dir", 
        type=str, 
        default="generated_agent", 
        help="Directory to save the generated code (default: generated_agent)."
    )
    args = cli_parser.parse_args()
    
    if not os.path.exists(args.manifest_file):
        print(f"Error: Manifest file not found at '{args.manifest_file}'")
        exit(1)
        
    llm_agents, sequential_agents, tools, llm_models = parse_manifest(args.manifest_file)
    generate_code(llm_agents, sequential_agents, tools, llm_models, args.output_dir)
    print(f"\nCode generation complete. Files are in '{args.output_dir}' directory.")